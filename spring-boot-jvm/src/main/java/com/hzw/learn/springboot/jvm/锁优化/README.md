## 锁优化
适应性自旋（Adaptive Spinning）、锁消除（Lock Enmination）、锁粗化（Lock Coarsening）、轻量级锁（Lightweight Locking）、偏向锁（Biased Locking）
### 1. 自旋锁和自适应自旋
自旋锁在JDK 1.4.2中引入，默认关闭，在JDK1.6中改为默认开启；
多核心处理器允许两个及以上线程同时并行执行，当多线程请求锁时，让后请求的线程执行一个忙循环（自旋）以等待锁，而不放弃处理器执行时间，线程不挂起，避免了线程挂起、恢复操作中的用户态向内核态转化带来较多的处理器时间消耗；

####Jvm参数

* 开启自旋
	`-XX:+UseSpinning`
* 自旋次数
	`-XX:PreBlockSpin`
	自旋次数默认值为10，可以使用该参数修改

####自旋锁不能替代阻塞
若自旋时间过长，那么自旋的线程会白白浪费大量的处理器时间，因此自旋的时间需要限制，当超过限制次数，那么该线程应当挂起以释放处理器。

####自适应自旋
JDK1.6引入了自适应自旋锁，自旋的时间限制由上一次该锁上的自旋时间和锁拥有者的状态来决定;
若该锁当前拥有者成功通过自旋等待获取了锁并正在持锁运行，那么允许当前自旋等待时间能够持续更长时间。但若该锁自旋很少成功，那么后续该锁的获取将省略自旋过程。
随着程序运行和性能监控信息的完善，虚拟机对锁的状况预测会越来越准确。

### 2. 锁消除
对一些代码上要求同步的资源，但通过**逃逸分析**确定该资源不存在竞争，虚拟机即时编译器在运行时会对这些同步措施进行消除。
**注意：**javac编译器会对代码进行优化，没有写同步措施的代码往往编译后会被加入同步逻辑，因此同步代码在java程序中往往比较普遍，锁消除策略对性能提升就很有必要了。
例如：
```java
public String test(String s1, String s2, String s3){
	return s1+s2+s3;
}
```
编译后
```java
public String test(String s1, String s2, String s3){
	StringBuffer  sb = new StringBuffer();	// 1.5之前
	// StringBuilder sb = new StringBuilder();	// 1.5之后
	sb.append(s1);
	sb.append(s2);
	sb.append(s3);
	return sb.toString();
}

```
上例中sb对象没有逃逸出方法，当开启逃逸分析后，此处StringBuffer对象sb中的锁就会被安全的消除。

### 3. 锁粗化
虚拟机探测到一串零碎的操作都对统一个对象加锁，将会把加锁同步的范围扩展（**粗化**）到整个操作串的外部，以减少细粒度的频繁加锁操作。


### **&&轻量级锁和偏向锁必须要理解HorSpot虚拟机的对象头：**
对象头分两部分，
第一部分存储对象的运行时数据，如HashCode、GC分代年龄等，这一部分称为**Mark Word**，这部分数据的长度在32为和64位的虚拟机中分别为32bit和64bit；
第二部分用于存储指向方法区对象类型数据的指针；
如果是数组对象，还会有一个额外的部分用于存储数组长度。
在对象**未锁定**的状态(**标志位为“01”**)下，32位虚拟机中（64位呢？？？）MarkWord的32bit空间，25bit用于存储HashCode，4bit用于存储分代年龄，**2bit用于存储锁标志位**，1bit固定为0
其他状态（**轻量级锁定**、**重量级锁定**、**GC标记**、**可偏向**）下MarkWord存储内容见下表

|存储内容|标志位|状态|
| :- | :--: | :- |
|对象哈希码、对象分代年龄 | 01 | 未锁定 |
|指向锁记录的指针          | 00 | **轻量级锁定**|
|指向重量级锁的指针        | 10 | 膨胀（**重量级锁定**） |
|空，不需要记录信息        | 11 | GC标记 |
|偏向线程ID、偏向时间戳、对象分代年龄 | 01 |可偏向|

下面回到轻量级锁和偏向锁

### 4. 轻量级锁
轻量级锁是JDK1.6中新加入的锁机制，传统锁机制可以称为重量级锁，轻量级锁的本意是在没有多线程竞争的前提下，减少重量级锁使用的操作系统互斥量产生的性能消耗，因此轻量级锁并不能代替重量级锁， 可以理解轻量级锁是重量级锁动作不用处理时的一个简化操作，当确实有两个线程抢锁时，还是要使用重量级锁处理。
#### 加锁
代码进入同步块时，判断同步对象是否被锁定（标志位是否为01），若未锁定则进行加锁操作：

>1.线程栈帧中建立锁记录（Lock Record）空间；<br/>
>2.拷贝锁对象的Mark Word到Lock Record中为 Displaced Mark Work；<br/>
>3.使用CAS操作将Mark Word更新为指向Lock Record的指针；
>>3.1 若更新成功则当前线程获得该对象锁，更新Mark Word的锁标志为00（轻量级锁标志）<br/>
>>3.2 若更新失败，检查Mark Word是否指向当前线程栈帧，
>>>3.2.1 若是则获得锁成功同步块继续执行；<br/>
>>>3.2.2 若不是则说明该锁已被其他线程占用，那轻量级锁需要膨胀为重量级锁，锁标志改为10，Mark Word中存储指向重量级锁（互斥量）的指针，后续等待锁的线程也都要进入阻塞状态。
#### 解锁
若Mark Word仍指向向Lock Record，那么使用CAS将Mark Word和Lock Record中的Displaced Mark Word替换，若果成功则整个过程完成，若失败则说明有其他线程尝试过获取该锁，那么在释放锁的同时要唤醒被挂起的线程。

通过经验来说，在大多数情况下锁对象在同步周期内都没有竞争情况，这无竞争中情况下轻量级锁能保证锁的功能又不会产生重量级锁的额外性能消耗，但如果发生锁竞争时，轻量级锁还是要膨胀为重量级锁，这比传统的重量级锁多了额外的CAS操作，所以当发生锁竞争时轻量级锁会比传统重量级锁更慢。
### 5. 偏向锁
偏向锁和轻量级锁大体相似，区别在于虚拟机使用CAS操作成功将Mark Word更新为指向Lock Record的指针后，会将Mark Word中的标志位设为“01”（偏向锁标志），并将取得这个锁的线程ID记录在Mark Word之中，该线程每次进入这个锁相关的同步块时，虚拟机不在进行任何的同步操作。
当有另一个线程尝试去获取这个锁时，则偏向模式结束，根据当前锁对象是否处于被锁定状态将锁对象标志位恢复为“01”（未锁定）或“00”（轻量级锁定），后续该锁的同步操作遵照轻量级锁操作。

偏向锁策略可以提高有同步但无竞争的程序性能，若果程序中大多数锁都是被多个线程访问，那禁用偏向锁反而可以提升性能。

#### 偏向锁机制通过虚拟机参数控制：
`-XX:+UseBiaseLocking` (开启，1.6默认开启)
`-XX:-UseBiaseLocking` (关闭)

#### 偏向锁、轻量级锁的状态转化及对象MarkWord的关系
![1](https://raw.githubusercontent.com/ZhengweiHou/spring-boot-parent-hzw/master/spring-boot-jvm/src/main/resources/docs/偏向锁、轻量级锁的状态转化及对象MarkWord的关系.png)



